# 手写 RPC 框架

## 简易版

- example-common：示例代码的公共依赖，包括接口、Model 等
- example-consumer：示例服务消费者代码
- example-provider：示例服务提供者代码
- yu-rpc-easy：简易版 RPC 框架



### 注册中心

- 简易 RPC 框架主要是跑通流程，所以暂时先不用第三方注册中心，直接把服务注册到服务提供者本地即可

- 使用线程安全的 ConcurrentHashMap 存储服务注册信息，key 为服务名称、value 为服务的实现类。之后就可以根据要调用的服务名称获取到对应的实现类，然后通过反射进行方法调用了。

### 序列化器

- Serializer接口、JdkSerializer实现类，具体代码用时照抄即可

### 服务提供者对于请求处理的业务流程

1. 反序列化请求为对象，并从请求对象中获取参数。
2. 根据服务名称从本地注册器中获取到对应的服务实现类。
3. 通过反射机制调用方法，得到返回结果。
4. 对返回结果进行封装和序列化，并写入到响应中。

### 静态代理

>  静态代理是指为每一个特定类型的接口或对象，编写一个代理类

- 这里是写一个UserServiceProxy类，只不过实现 getUser 方法时，不是复制粘贴服务提供者 UserServiceImpl 中的代码，而是要构造 HTTP 请求去调用服务提供者

- 缺点明显，我们如果要给每个服务接口都写一个实现类，是非常麻烦的，这种代理方式的灵活性很差！

  

**所以 RPC 框架中，我们会使用动态代理**



### 动态代理

> 动态代理的作用是，根据要生成的对象的类型，自动生成一个代理对象

#### JDK动态代理

- 在 RPC 模块中编写动态代理类 ServiceProxy，需要实现 **InvocationHandler** 接口的 **invoke** 方法
- 实现部分与静态代理部分代码一致，只需修改方法服务名、参数、类型

#### 工厂设计模式

> 动态代理工厂，作用是根据指定类创建动态代理对象